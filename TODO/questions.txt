why streams
connection pool
data strucutre for mySql,mongodb
tranactional
difference between rest controller and controlller
proxy setup
cache setup
timeout setup in java
cassandra vs mongoDB
normalization and denormalization
mySql to cassandra shifting
linkedlist vs arraylist
jdbc classFor
Auth token
microservices
query in mongoDB
how jobs get data from rabbitMQ
runnable interface
customer centric suggestion
cyclic barrier
circuit breaker

AWS
ORM-hibernate
how jpa connects to db
how to add multiple database support
design pattern
DATA EXPORT
LOCKS
collection framework- when to choose set and list
reverse a list using recursion
cycle detection
bubble sort
example of design pattens in Spring
check if string is rotation of other string or not
how spring security works
WHERE INDEXES INFO is stored
how to limit the search totop 100 out of 10000 on db side pagination
how to handle lock on db side,and jump to next available
A server can have how many consecutive read write requests
where your server is hosted(A)
AnyThing you have done from your side - Customer obsession(A)
Count of good nodes(A)
find count of a number in a array(A)
how to get top 100 result based on time.How to optimize db queries
how to do consistent hashing using userID
Function Overloading which funcion will be clled

Generics

Functional Programming
List<Employee> filterEmployees(List<Employee> employees,Set<String> deignations){
	//return employees.stream().filter(emp->deignations.contains(emp.getDesignation()).collect(Collectors.toList());
	return employees.stream().filter(Employee::getStatus).collect(Collectors.toList());
}
Functional Interface
lambda perdicate filter how indetify
Default Method

Method Reference

Immutable

class Employee{
	final Employee emp;
	Employee(){
		emp=new Employee();
	}
	
	Employee getEmployee(){
		return emp;
	}
	Set
}

? 

TypeEraser

Employee emp1,emp2,emp3;
@qualifer

@Component
class c{
	@
	ThirdParty reference;

} 
CrossOrigin

class ThridParty

@Confiuration
@AutoConfiguration

@preDestroy

@postConstruct


i1 i2 getName()  getI1()  getI2()

public sttic void getName(int

List<String>  

public string getname(){
	try{
		return "try";
	}catch(Exception e){
		return "catch";
	}catch(){

	}
	finally(){
		return "finally";
	}
	
}



@PostMapping("/createAccount/1")
List<Employee> createAccount(@RequestBody Employye emp,@Required @PathVaribale id){
	employeeService.save(emp);
}

/createAccount?id="1"
10 Emp,id,
1-
""All

Name marks

String name="Arun Bhati";
" "  dup  reverse

ithbnura

String getCustomizeString(String str){
	char[] chars=str.toCharArray();
	chars[] newArray=reverse(removeDuplicatesAndEmptyCharsUpper(chars));
	StringBuilder s=getString(newArray);
	return s.toString();
}

char[] removeDuplicatesAndEmptyCharsUpper(char[] chars){
	StringBuilder s=new StringBuilder();
	HashSet<Charcater> set=new HashSet<>();
	for(int i=0;i<chars.lrngth;++i){
		if(chars[i]=' '|| set.contains(chrs[i]) continue;
		if(chars[i]>='A' && chars[i]<='Z'){
			chars[i]=chars[i]-'A'+'a';
		}
		set.add(chars[i]);
		s.append(chars[i]);
	}
	return s.toString().toCharArray();
}

char[] reverse(char[] arr){
	int l=0,h=arr.length-1;
	while(l<=h){
		char temp=arr[l];
		arr[l]=arr[h];
		arr[h]=temp;
		++l;
		--h;
	}
	return arr;
}


Difference between array and linked list, under which situation would u choose one over the other

3 largest element in MYSQl


class DNode{
	String key;
	String value;
	DNode prev;
	DNode next;

	public DNode(){}
	public DNode(String key,String value){
		this.key=key;
		this.value=value;
	}
}

dumyyH   DuumyT

class LRU{
	int size=0;
	int limit;
	        //key   //node
	Hashmap<String,DNode> map;
	DNode head=new DNode(),tail=new DNode();
	public LRU(int limit){
		map=new HashMap<>();
		head.next=tail;
		tail.prev=head;
        this.limit=limit;
	}

	String get(String key){
		if(!map.contains(key)) {
			String data=dataService.fetchData(key);
			return insert(key,data);
		}
		DNode temp=map.get(key);
		moveToHead(temp);
		return temp.value;
	}

	void moveToHead(DNode temp){
		node.next=temp;
		node.prev=head;
		head.next=node;
		map.put(key,node);
		
	}

	String insert(String key,String value){
		if(map.contains(key)) return;
		if(size==limit){
			delete();
		}
		DNode node=new DNode(key,value);
		DNode temp=head.next;
		moveToHead(temp);
		++size;
		return value;
	}
	
	void delete(){
		
		Node temp=tail.prev;
		Node prev=temp.prev;
		prev.next=tail;
		tail.prev=prev;
		map.remove(tempkey);
		--size;
	}
}
